{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Getting Started # Requirements # Your server/development computer must meet these requirements in order to run Invention Framework Apps: PHP v8.0.0 or higher NodeJS JavaScript Runtime v12.0.0 or higher PHP PDO extension with SQLite and MySQL driver PHP JSON extension Installation # You can install Invention using Composer : composer create-project osn/invention:dev-main myapp This will create an Invention project in myapp/ directory. Quick start # Make sure that PHP is installed globally, otherwise the app might not work properly. Go to your project directory and run: npm install npm run dev php console serve The first command installs the project dependencies, the second one compiles the javascript and css files and puts them into the public/ folder and the last command starts a local development server (PHP's built in dev server) at localhost:8080 . You can now open http://localhost:8080 using your favourite browser.","title":"Getting Started"},{"location":"#getting-started","text":"","title":"Getting Started"},{"location":"#requirements","text":"Your server/development computer must meet these requirements in order to run Invention Framework Apps: PHP v8.0.0 or higher NodeJS JavaScript Runtime v12.0.0 or higher PHP PDO extension with SQLite and MySQL driver PHP JSON extension","title":"Requirements"},{"location":"#installation","text":"You can install Invention using Composer : composer create-project osn/invention:dev-main myapp This will create an Invention project in myapp/ directory.","title":"Installation"},{"location":"#quick-start","text":"Make sure that PHP is installed globally, otherwise the app might not work properly. Go to your project directory and run: npm install npm run dev php console serve The first command installs the project dependencies, the second one compiles the javascript and css files and puts them into the public/ folder and the last command starts a local development server (PHP's built in dev server) at localhost:8080 . You can now open http://localhost:8080 using your favourite browser.","title":"Quick start"},{"location":"basics/basic_configuration/","text":"Basic Configuration # The first thing you should do is to edit the .env file. This file has all environment-related configuration variables. Database Connection # In the .env file, there are some DB_ prefixed variables, these are related to database connection of your app. The DB_VENDOR is the database connection type you want to use. Default is MySQL. See the valid values for this variable . The DB_HOST is the hostname of the database server. The DB_PORT is the port number of the database server. The DB_USER is the username that you want to use to authenticate with the database server. The DB_PASSWORD is the password for the given user. The DB_NAME is the database name on your database server. But if you're using SQLite, you need to specify an absolute path to the DB file in this variable. Also, in this case you only need to specify the DB_VENDOR and no other DB variable is required. Older versions of SQLite does not support some operations such as `ALTER...CHANGE` or `ALTER...DROP` etc, so there's a chance of loosing data if you do such operations with SQLite. Supported Database Vendors # Currently invention only supports MySQL, MariaDB and SQLite. MySQL is recommended. Vendor Name Value for DB_VENDOR MySQL mysql MariaDB mariadb SQLite sqlite Other Configurations # Variable Name Type Description TMP_DIR String Temporary file storage directory. CACHE_DIR String Cache file storage directory. CONF_FILE String Configuration file. APP_ENV String Specify the app environment.","title":"Basic Configuration"},{"location":"basics/basic_configuration/#basic-configuration","text":"The first thing you should do is to edit the .env file. This file has all environment-related configuration variables.","title":"Basic Configuration"},{"location":"basics/basic_configuration/#database-connection","text":"In the .env file, there are some DB_ prefixed variables, these are related to database connection of your app. The DB_VENDOR is the database connection type you want to use. Default is MySQL. See the valid values for this variable . The DB_HOST is the hostname of the database server. The DB_PORT is the port number of the database server. The DB_USER is the username that you want to use to authenticate with the database server. The DB_PASSWORD is the password for the given user. The DB_NAME is the database name on your database server. But if you're using SQLite, you need to specify an absolute path to the DB file in this variable. Also, in this case you only need to specify the DB_VENDOR and no other DB variable is required. Older versions of SQLite does not support some operations such as `ALTER...CHANGE` or `ALTER...DROP` etc, so there's a chance of loosing data if you do such operations with SQLite.","title":"Database Connection"},{"location":"basics/basic_configuration/#supported-database-vendors","text":"Currently invention only supports MySQL, MariaDB and SQLite. MySQL is recommended. Vendor Name Value for DB_VENDOR MySQL mysql MariaDB mariadb SQLite sqlite","title":"Supported Database Vendors"},{"location":"basics/basic_configuration/#other-configurations","text":"Variable Name Type Description TMP_DIR String Temporary file storage directory. CACHE_DIR String Cache file storage directory. CONF_FILE String Configuration file. APP_ENV String Specify the app environment.","title":"Other Configurations"},{"location":"basics/creating_a_new_route/","text":"Creating a new route # First of all, open routes/web.php file and add this code: Route::get(\"/my-page\", function(){ return \"Hello world!\"; }); This will create a new route and whenever a GET request is made on /my-page the callback function will be fired; and its return value Hello world! will be outputted. Congratulations! You've created your first route!","title":"Creating a new route"},{"location":"basics/creating_a_new_route/#creating-a-new-route","text":"First of all, open routes/web.php file and add this code: Route::get(\"/my-page\", function(){ return \"Hello world!\"; }); This will create a new route and whenever a GET request is made on /my-page the callback function will be fired; and its return value Hello world! will be outputted. Congratulations! You've created your first route!","title":"Creating a new route"},{"location":"basics/file_and_folder_structure/","text":"File & Folder Structure # A fresh invention-based project will look like this: - project_root/ - app/ - Commands/ - Events/ - Exceptions/ - Http/ - Controllers/ - Middleware/ - Requests/ - Resources/ - Config.php - Initializers/ - Models/ - Policies/ - config/ - database/ - factories/ - migrations/ - seeders/ - public/ - index.php - resources/ - sass/ - js/ - views/ - components/ - errors/ - layouts/ welcome.power.php - routes/ - api.php - auth.php - web.php - storage/ - tests/ - var/ - cache/ - dumps/ - log/ - tmp/ - vendor/ - .editorconfig - .env - .env.example - .gitignore - ChangeLog.md - composer.json - composer.lock - console - LICENSE - package.json - package-lock.json - README.md - webpack.config.js - webpack.development.js - webpack.production.js A short overview of some important directories is given below. The app/ directory # The app/ directory contains almost 99% of the application code. Models, Controllers and Middleware are found here. The config/ directory # This directory contains the application configuration files. The database/ directory # This directory contains factories, migrations and seeders. The public/ directory # This directory is the web server root. The index.php file in this directory is the entry point of the app. Never put any personal or sensitive information/file in `public` directory. The resources/ directory # Static/dynamic assets such as javascript files, typescript files, css/sass files, images and views go here. The routes/ directory # This directory contains all of the application routes. The storage/ directory # This directory is for the application data storage. You can store uploaded files here. The tests/ directory # PHPUnit tests directory. The var/ directory # This is the variables directory. Runtime and temporary files, cache and log files go here.","title":"File & Folder Structure"},{"location":"basics/file_and_folder_structure/#file-folder-structure","text":"A fresh invention-based project will look like this: - project_root/ - app/ - Commands/ - Events/ - Exceptions/ - Http/ - Controllers/ - Middleware/ - Requests/ - Resources/ - Config.php - Initializers/ - Models/ - Policies/ - config/ - database/ - factories/ - migrations/ - seeders/ - public/ - index.php - resources/ - sass/ - js/ - views/ - components/ - errors/ - layouts/ welcome.power.php - routes/ - api.php - auth.php - web.php - storage/ - tests/ - var/ - cache/ - dumps/ - log/ - tmp/ - vendor/ - .editorconfig - .env - .env.example - .gitignore - ChangeLog.md - composer.json - composer.lock - console - LICENSE - package.json - package-lock.json - README.md - webpack.config.js - webpack.development.js - webpack.production.js A short overview of some important directories is given below.","title":"File &amp; Folder Structure"},{"location":"basics/file_and_folder_structure/#the-app-directory","text":"The app/ directory contains almost 99% of the application code. Models, Controllers and Middleware are found here.","title":"The app/ directory"},{"location":"basics/file_and_folder_structure/#the-config-directory","text":"This directory contains the application configuration files.","title":"The config/ directory"},{"location":"basics/file_and_folder_structure/#the-database-directory","text":"This directory contains factories, migrations and seeders.","title":"The database/ directory"},{"location":"basics/file_and_folder_structure/#the-public-directory","text":"This directory is the web server root. The index.php file in this directory is the entry point of the app. Never put any personal or sensitive information/file in `public` directory.","title":"The public/ directory"},{"location":"basics/file_and_folder_structure/#the-resources-directory","text":"Static/dynamic assets such as javascript files, typescript files, css/sass files, images and views go here.","title":"The resources/ directory"},{"location":"basics/file_and_folder_structure/#the-routes-directory","text":"This directory contains all of the application routes.","title":"The routes/ directory"},{"location":"basics/file_and_folder_structure/#the-storage-directory","text":"This directory is for the application data storage. You can store uploaded files here.","title":"The storage/ directory"},{"location":"basics/file_and_folder_structure/#the-tests-directory","text":"PHPUnit tests directory.","title":"The tests/ directory"},{"location":"basics/file_and_folder_structure/#the-var-directory","text":"This is the variables directory. Runtime and temporary files, cache and log files go here.","title":"The var/ directory"},{"location":"basics/more_about_routing/","text":"More about Routing # You can use PCRE based Regular Expressions in routes to get dynamic values from the request. For example: Route::get('/foo/(\\d+)', function ($id) { echo \"Number: $id\"; }); Will call the given closure each time when a GET request is made which matches the PCRE pattern ^/foo/(\\d+)$ , and pass the matched values to the closure in the same order. So, if we make a GET request to /foo/52 , we'll see Number: 52 in the browser. You can have more complex PCRE Patterns as you want but don't forget to use the right order!","title":"More about routing"},{"location":"basics/more_about_routing/#more-about-routing","text":"You can use PCRE based Regular Expressions in routes to get dynamic values from the request. For example: Route::get('/foo/(\\d+)', function ($id) { echo \"Number: $id\"; }); Will call the given closure each time when a GET request is made which matches the PCRE pattern ^/foo/(\\d+)$ , and pass the matched values to the closure in the same order. So, if we make a GET request to /foo/52 , we'll see Number: 52 in the browser. You can have more complex PCRE Patterns as you want but don't forget to use the right order!","title":"More about Routing"},{"location":"basics/mvc_basic_concepts/","text":"Basic MVC Concepts # MVC is a software pattern. It stands for Model-View-Controller. Here is a short brief about Models, Views, Controllers: Model # A model is a special class that is used work with database. It represents a single row of a table. Within a model, you can do CRUD (Create-Read-Update-Delete) Operations and other useful stuff. Controllers # Controller is a piece of class that holds the application logic. A Controller contains some action methods and each method contains different logic. Optionally controllers can also pass data to the views and return it the user so that the user can see a dynamic webpage. Views # Views are the templates of a webpage, we can pass data to the views and represent those data to the user, dynamically.","title":"Basic MVC Concepts"},{"location":"basics/mvc_basic_concepts/#basic-mvc-concepts","text":"MVC is a software pattern. It stands for Model-View-Controller. Here is a short brief about Models, Views, Controllers:","title":"Basic MVC Concepts"},{"location":"basics/mvc_basic_concepts/#model","text":"A model is a special class that is used work with database. It represents a single row of a table. Within a model, you can do CRUD (Create-Read-Update-Delete) Operations and other useful stuff.","title":"Model"},{"location":"basics/mvc_basic_concepts/#controllers","text":"Controller is a piece of class that holds the application logic. A Controller contains some action methods and each method contains different logic. Optionally controllers can also pass data to the views and return it the user so that the user can see a dynamic webpage.","title":"Controllers"},{"location":"basics/mvc_basic_concepts/#views","text":"Views are the templates of a webpage, we can pass data to the views and represent those data to the user, dynamically.","title":"Views"},{"location":"controllers/action_methods_and_their_work/","text":"Action Methods and Their Work # There are some standard controller actions which can be used to enhance your app's code. You're not forced to use these methods, but it is recommended to do so. The index() method # Used in : Resource and API controllers Displays a listing of the resource. The view() method # Used in : Resource and API controllers Arguments : $id Displays information about a specific resource. The create() method # Used in : Resource controllers Displays a form for taking required data from the user to create a new resource. The store() method # Used in : Resource and API controllers Arguments : \\OSN\\Framework\\Core\\Request $request Creates a brand new resource with the user input. The edit() method # Used in : Resource controllers Arguments : \\OSN\\Framework\\Core\\Request $request, $id Displays a form for taking required data from the user to modify an existing resource. The update() method # Used in : Resource and API controllers Arguments : \\OSN\\Framework\\Core\\Request $request, $id Updates an existing resource according to the user input. The delete() method # Used in : Resource and API controllers Arguments : $id Deletes an existing resource.","title":"Action Methods and Their Work"},{"location":"controllers/action_methods_and_their_work/#action-methods-and-their-work","text":"There are some standard controller actions which can be used to enhance your app's code. You're not forced to use these methods, but it is recommended to do so.","title":"Action Methods and Their Work"},{"location":"controllers/action_methods_and_their_work/#the-index-method","text":"Used in : Resource and API controllers Displays a listing of the resource.","title":"The index() method"},{"location":"controllers/action_methods_and_their_work/#the-view-method","text":"Used in : Resource and API controllers Arguments : $id Displays information about a specific resource.","title":"The view() method"},{"location":"controllers/action_methods_and_their_work/#the-create-method","text":"Used in : Resource controllers Displays a form for taking required data from the user to create a new resource.","title":"The create() method"},{"location":"controllers/action_methods_and_their_work/#the-store-method","text":"Used in : Resource and API controllers Arguments : \\OSN\\Framework\\Core\\Request $request Creates a brand new resource with the user input.","title":"The store() method"},{"location":"controllers/action_methods_and_their_work/#the-edit-method","text":"Used in : Resource controllers Arguments : \\OSN\\Framework\\Core\\Request $request, $id Displays a form for taking required data from the user to modify an existing resource.","title":"The edit() method"},{"location":"controllers/action_methods_and_their_work/#the-update-method","text":"Used in : Resource and API controllers Arguments : \\OSN\\Framework\\Core\\Request $request, $id Updates an existing resource according to the user input.","title":"The update() method"},{"location":"controllers/action_methods_and_their_work/#the-delete-method","text":"Used in : Resource and API controllers Arguments : $id Deletes an existing resource.","title":"The delete() method"},{"location":"controllers/creating_and_understanding_a_basic_controller/","text":"Creating and Understanding a Basic Controller # All of the controllers are placed at app/Http/Controllers/ directory. The controller class name should have the word Controller after its name. For example, DogController , CatController ... etc, and it should extend the OSN\\Framework\\Core\\Controller class. The methods inside of a controller are generally known as actions . These actions contain specific logic for processing data and rendering a view. A basic controller template should look like this: <?php namespace App\\Http\\Controllers; use OSN\\Framework\\Core\\Controller; class FooController extends Controller { public function index() { // code... } } Basically you'll need this template each time when you create a new controller. But with Invention, you can make use of the Console by running php console make:controller FooController at the top directory of your project. This will create a new file inside the app/Http/Controllers/ directory and the file will contain the basic template like above. This will speed up your work! Registering a controller # OK, so now we have our first controller; it's time to register it! Open the routes/web.php file and add the following line: Route::get('/foo', [\\App\\Http\\Controllers\\FooController::class, 'index']); As you can see, instead of passing a closure to the get() method, we've passed an array which has the controller class name at index 0 and the method name at index 1. now this simply means that \"Call the index method on FooController whenever a GET request is made on /test\". More about controllers # There are generally two type of controllers: API and Resource/Web. The API controllers are minimalistic and optimized for JSON data. The Resource controllers are for humans; these are optimized for managing a resource in a user-friendly way. You can have more methods/actions and register them in the routes. The method naming is fully depending on you, but there is a list of standards for the controller method names and the route paths, which is recommended to follow. The list is given below: (In this list, we've used /foo as base route) For the Resource Controllers # HTTP Method Route Action Method GET /foo index() GET /foo/(\\d+) view($id) GET /foo/create create() POST /foo store($id) GET /foo/(\\d+)/edit edit($id) PUT /foo/(\\d+) update($id) PATCH /foo/(\\d+) update($id) DELETE /foo/(\\d+) delete($id) For the API Controllers # HTTP Method Route Action Method GET /foo index() GET /foo/(\\d+) view($id) POST /foo store($id) PUT /foo/(\\d+) update($id) PATCH /foo/(\\d+) update($id) DELETE /foo/(\\d+) delete($id) Each of these action methods are explained here . Now, if you follow the above naming conventions, then you get an advantage. Instead of registering all of the methods one-by-one, you can directly use one of Route::assignAPIController($path, $controller) and Route::assignWebController($path, $controller) . The assignAPIController() registers all applicable routes for an APi controller; and the assignWebController() registers routes for a resource controller.","title":"Creating and Understanding a Basic Controller"},{"location":"controllers/creating_and_understanding_a_basic_controller/#creating-and-understanding-a-basic-controller","text":"All of the controllers are placed at app/Http/Controllers/ directory. The controller class name should have the word Controller after its name. For example, DogController , CatController ... etc, and it should extend the OSN\\Framework\\Core\\Controller class. The methods inside of a controller are generally known as actions . These actions contain specific logic for processing data and rendering a view. A basic controller template should look like this: <?php namespace App\\Http\\Controllers; use OSN\\Framework\\Core\\Controller; class FooController extends Controller { public function index() { // code... } } Basically you'll need this template each time when you create a new controller. But with Invention, you can make use of the Console by running php console make:controller FooController at the top directory of your project. This will create a new file inside the app/Http/Controllers/ directory and the file will contain the basic template like above. This will speed up your work!","title":"Creating and Understanding a Basic Controller"},{"location":"controllers/creating_and_understanding_a_basic_controller/#registering-a-controller","text":"OK, so now we have our first controller; it's time to register it! Open the routes/web.php file and add the following line: Route::get('/foo', [\\App\\Http\\Controllers\\FooController::class, 'index']); As you can see, instead of passing a closure to the get() method, we've passed an array which has the controller class name at index 0 and the method name at index 1. now this simply means that \"Call the index method on FooController whenever a GET request is made on /test\".","title":"Registering a controller"},{"location":"controllers/creating_and_understanding_a_basic_controller/#more-about-controllers","text":"There are generally two type of controllers: API and Resource/Web. The API controllers are minimalistic and optimized for JSON data. The Resource controllers are for humans; these are optimized for managing a resource in a user-friendly way. You can have more methods/actions and register them in the routes. The method naming is fully depending on you, but there is a list of standards for the controller method names and the route paths, which is recommended to follow. The list is given below: (In this list, we've used /foo as base route)","title":"More about controllers"},{"location":"controllers/creating_and_understanding_a_basic_controller/#for-the-resource-controllers","text":"HTTP Method Route Action Method GET /foo index() GET /foo/(\\d+) view($id) GET /foo/create create() POST /foo store($id) GET /foo/(\\d+)/edit edit($id) PUT /foo/(\\d+) update($id) PATCH /foo/(\\d+) update($id) DELETE /foo/(\\d+) delete($id)","title":"For the Resource Controllers"},{"location":"controllers/creating_and_understanding_a_basic_controller/#for-the-api-controllers","text":"HTTP Method Route Action Method GET /foo index() GET /foo/(\\d+) view($id) POST /foo store($id) PUT /foo/(\\d+) update($id) PATCH /foo/(\\d+) update($id) DELETE /foo/(\\d+) delete($id) Each of these action methods are explained here . Now, if you follow the above naming conventions, then you get an advantage. Instead of registering all of the methods one-by-one, you can directly use one of Route::assignAPIController($path, $controller) and Route::assignWebController($path, $controller) . The assignAPIController() registers all applicable routes for an APi controller; and the assignWebController() registers routes for a resource controller.","title":"For the API Controllers"},{"location":"controllers/rendering_a_view_from_a_controller/","text":"Rendering a View from a Controller # It is common to render a view from a controller. To do this, you have 3 ways: Using $this->render() : <?php namespace App\\Http\\Controllers; use OSN\\Framework\\Core\\Controller; class FooController extends Controller { public function index() { return $this->render(\"foo\"); } } Using view() : <?php namespace App\\Http\\Controllers; use OSN\\Framework\\Core\\Controller; class FooController extends Controller { public function index() { return view(\"foo\"); } } Using new View() : <?php namespace App\\Http\\Controllers; use OSN\\Framework\\Core\\Controller; use OSN\\Framework\\View\\View; class FooController extends Controller { public function index() { return new View(\"foo\"); } } Naming the views # There is no rule for naming views that you must follow, but there are some standards that you can follow to enhance your code. You should keep all views relating to a controller within a separate folder. The folder name should match the controller's name (after removing the word Controller and then converting it into lowercase) and should be in snake case. For example, in the above code, the controller is named FooController , the views relating to it will go to the folder foo . The view names should match the controller's action name and should be in snake case. For example, in the above code, the only action is named index in FooController , the view for this action will be named index .","title":"Rendering a View from a Controller"},{"location":"controllers/rendering_a_view_from_a_controller/#rendering-a-view-from-a-controller","text":"It is common to render a view from a controller. To do this, you have 3 ways: Using $this->render() : <?php namespace App\\Http\\Controllers; use OSN\\Framework\\Core\\Controller; class FooController extends Controller { public function index() { return $this->render(\"foo\"); } } Using view() : <?php namespace App\\Http\\Controllers; use OSN\\Framework\\Core\\Controller; class FooController extends Controller { public function index() { return view(\"foo\"); } } Using new View() : <?php namespace App\\Http\\Controllers; use OSN\\Framework\\Core\\Controller; use OSN\\Framework\\View\\View; class FooController extends Controller { public function index() { return new View(\"foo\"); } }","title":"Rendering a View from a Controller"},{"location":"controllers/rendering_a_view_from_a_controller/#naming-the-views","text":"There is no rule for naming views that you must follow, but there are some standards that you can follow to enhance your code. You should keep all views relating to a controller within a separate folder. The folder name should match the controller's name (after removing the word Controller and then converting it into lowercase) and should be in snake case. For example, in the above code, the controller is named FooController , the views relating to it will go to the folder foo . The view names should match the controller's action name and should be in snake case. For example, in the above code, the only action is named index in FooController , the view for this action will be named index .","title":"Naming the views"},{"location":"controllers/return_values_of_a_controller_action/","text":"Return Values of a Controller Action # A controller action can return one of the following types: string int bool array object \\JsonSerializable \\OSN\\Framework\\View\\View \\OSN\\Framework\\Core\\Response So basically you can return everything except null .","title":"Return Values of a Controller Action"},{"location":"controllers/return_values_of_a_controller_action/#return-values-of-a-controller-action","text":"A controller action can return one of the following types: string int bool array object \\JsonSerializable \\OSN\\Framework\\View\\View \\OSN\\Framework\\Core\\Response So basically you can return everything except null .","title":"Return Values of a Controller Action"},{"location":"controllers/returning_custom_response/","text":"Returning Custom Response # To return a custom response, you have these ways: Using Response object: public function index() { return new \\OSN\\Framework\\Core\\Response('', 403); } Using response() function: public function index() { return response('', 403); } Both the Response contructor and the response() function takes the first argument as the response content and the second argument as the status code. Finally you may pass an array of headers to them: public function index() { return response('', 403, [ 'X-Powered-By' => \"Invention+PHP/8.x\" ]); }","title":"Returning Custom Response"},{"location":"controllers/returning_custom_response/#returning-custom-response","text":"To return a custom response, you have these ways: Using Response object: public function index() { return new \\OSN\\Framework\\Core\\Response('', 403); } Using response() function: public function index() { return response('', 403); } Both the Response contructor and the response() function takes the first argument as the response content and the second argument as the status code. Finally you may pass an array of headers to them: public function index() { return response('', 403, [ 'X-Powered-By' => \"Invention+PHP/8.x\" ]); }","title":"Returning Custom Response"},{"location":"core/application_and_entry_points/","text":"Application & Entry Points # The public/index.php file is the entry point of the application; it just creates an instance of the App class and calls the run() method on it. This file is always served by the HTTP server (e. g. Apache). Also, there is a public/.htaccess file which configures apache to always serve the index.php file. Understanding how the application works # Whenever an instance of App is created, it initializes other application services. This initialization process is done by the Initializers . Your application initializers are placed at app/Initializers . These initializers generally look like this: <?php namespace App\\Initializers; use OSN\\Framework\\Core\\Initializer; class AppInitializer extends Initializer { /** * Before app initialization. * Note that some components/objects might not be initialized at this point. * * @return void */ public function preinit() { // } /** * Initialize the app. * * @return void */ public function init() { // } /** * After app initialization, when the run() method is called. * * @return void */ public function afterinit() { // } } The preinit() method is called before the application gets ready; the init() method is fired when the app is ready and about to boot; the afterinit() method is invoked after the run() method is called on the application instance. You can register or configure your application services in those methods. There are already some Initializers present on your application, but you can create your own if you need. After that, when the run() method is called, it simply calls Router::resolve() method, which takes some info from the request and returns the output based on those info. And finally, the output is printed to the client's browser.","title":"Application & Entry Points"},{"location":"core/application_and_entry_points/#application-entry-points","text":"The public/index.php file is the entry point of the application; it just creates an instance of the App class and calls the run() method on it. This file is always served by the HTTP server (e. g. Apache). Also, there is a public/.htaccess file which configures apache to always serve the index.php file.","title":"Application &amp; Entry Points"},{"location":"core/application_and_entry_points/#understanding-how-the-application-works","text":"Whenever an instance of App is created, it initializes other application services. This initialization process is done by the Initializers . Your application initializers are placed at app/Initializers . These initializers generally look like this: <?php namespace App\\Initializers; use OSN\\Framework\\Core\\Initializer; class AppInitializer extends Initializer { /** * Before app initialization. * Note that some components/objects might not be initialized at this point. * * @return void */ public function preinit() { // } /** * Initialize the app. * * @return void */ public function init() { // } /** * After app initialization, when the run() method is called. * * @return void */ public function afterinit() { // } } The preinit() method is called before the application gets ready; the init() method is fired when the app is ready and about to boot; the afterinit() method is invoked after the run() method is called on the application instance. You can register or configure your application services in those methods. There are already some Initializers present on your application, but you can create your own if you need. After that, when the run() method is called, it simply calls Router::resolve() method, which takes some info from the request and returns the output based on those info. And finally, the output is printed to the client's browser.","title":"Understanding how the application works"},{"location":"models/intro_to_the_models/","text":"Into to the Models # The models are simple class which works as a wrapper for your application data. They provide an elegant way to interact with your database and process data. You can imagine that each model instance is an indivisual row of a database table. Creating your first model # Alright, open the command line and run: php console make:model Post This will create a new model at app/Models/ with the name of Post . There is a simple relation between the table names and model names. Models must have a matching name with its corresponsing table, but it should be singular. For tables, it must be plural. You can think that there exists a table named posts in our DB. The newly created model should look like this: <?php namespace App\\Models; use OSN\\Framework\\Core\\Model; use OSN\\Framework\\Database\\HasFactory; class Post extends Model { use HasFactory; } For now, there is no need to edit this file. Let's create the posts table and add some data to it now: MySQL/MariaDB: CREATE TABLE posts( id INT NOT NULL UNIQUE AUTO_INCREMENT, title TEXT NOT NULL, PRIMARY KEY (id) ) SQLite: CREATE TABLE posts( id INT NOT NULL PRIMARY KEY, title TEXT NOT NULL ) Add data to the table: id title 1 Foo 2 Bar 3 Car 4 Cat 5 PHP Now let's go to an action method of a live controller in the app and fetch all data with the model: public function index() { $data = \\App\\Models\\Post::all(); /* Use all() method fetch all the data from the corresponding table. Returns an \\OSN\\Framework\\Core\\Collection object which is equivalent to an array */ return $data; } So the $data will hold all the data. Now invention is intelligent enough to check if the controller action is returning an array/object and if it is then convert the array/object to JSON. So we'll get a JSON output in the browser. It should look like this: [ { \"id\": 1, \"title\": \"Foo\" }, { \"id\": 2, \"title\": \"Bar\" }, { \"id\": 3, \"title\": \"Car\" }, { \"id\": 4, \"title\": \"Cat\" }, { \"id\": 5, \"title\": \"PHP\" } ] Great! You've just made use of a model! How it works # First, the model tries to find a table name for itself by looking for a $table static property. If doesn't exist then it adds an s after the model class name and then converts it into lowercase and sets it as the table name. All kind of operations will use this table name. Then when the all() function is fired, it simply makes a query into the database: SELECT * FROM posts and fetches the data using PDO. Then it converts the data into a Collection of Models and returns it. The Collection class implements the JsonSerializable Interface, so that it can customize its appearance when it is converted to JSON.","title":"Into to the Models"},{"location":"models/intro_to_the_models/#into-to-the-models","text":"The models are simple class which works as a wrapper for your application data. They provide an elegant way to interact with your database and process data. You can imagine that each model instance is an indivisual row of a database table.","title":"Into to the Models"},{"location":"models/intro_to_the_models/#creating-your-first-model","text":"Alright, open the command line and run: php console make:model Post This will create a new model at app/Models/ with the name of Post . There is a simple relation between the table names and model names. Models must have a matching name with its corresponsing table, but it should be singular. For tables, it must be plural. You can think that there exists a table named posts in our DB. The newly created model should look like this: <?php namespace App\\Models; use OSN\\Framework\\Core\\Model; use OSN\\Framework\\Database\\HasFactory; class Post extends Model { use HasFactory; } For now, there is no need to edit this file. Let's create the posts table and add some data to it now: MySQL/MariaDB: CREATE TABLE posts( id INT NOT NULL UNIQUE AUTO_INCREMENT, title TEXT NOT NULL, PRIMARY KEY (id) ) SQLite: CREATE TABLE posts( id INT NOT NULL PRIMARY KEY, title TEXT NOT NULL ) Add data to the table: id title 1 Foo 2 Bar 3 Car 4 Cat 5 PHP Now let's go to an action method of a live controller in the app and fetch all data with the model: public function index() { $data = \\App\\Models\\Post::all(); /* Use all() method fetch all the data from the corresponding table. Returns an \\OSN\\Framework\\Core\\Collection object which is equivalent to an array */ return $data; } So the $data will hold all the data. Now invention is intelligent enough to check if the controller action is returning an array/object and if it is then convert the array/object to JSON. So we'll get a JSON output in the browser. It should look like this: [ { \"id\": 1, \"title\": \"Foo\" }, { \"id\": 2, \"title\": \"Bar\" }, { \"id\": 3, \"title\": \"Car\" }, { \"id\": 4, \"title\": \"Cat\" }, { \"id\": 5, \"title\": \"PHP\" } ] Great! You've just made use of a model!","title":"Creating your first model"},{"location":"models/intro_to_the_models/#how-it-works","text":"First, the model tries to find a table name for itself by looking for a $table static property. If doesn't exist then it adds an s after the model class name and then converts it into lowercase and sets it as the table name. All kind of operations will use this table name. Then when the all() function is fired, it simply makes a query into the database: SELECT * FROM posts and fetches the data using PDO. Then it converts the data into a Collection of Models and returns it. The Collection class implements the JsonSerializable Interface, so that it can customize its appearance when it is converted to JSON.","title":"How it works"},{"location":"views/intro_to_the_views/","text":"Intro to the Views # In the route callback function, instead of returning some string, we render a view and then return it. We can do this using the global view() function or return a View object: Route::get(\"/\", function(){ return view('home'); }); Route::get(\"/home\", function(){ return new View('home'); }); Now this view() function or View object checks if the resources/views/ directory contains a view named [given_name].php or [given_name].power.php ; if exists then it returns the whole content of the file as a string. In this case the [given_name] is home . You can specify folders: Route::get(\"/home\", function(){ return new View('test/home'); }); Using . (dot): Route::get(\"/home\", function(){ return new View('test.home'); // same as above }); If the given view doesn't exist then it will throw a `FileNotFoundException`. Passing data to the views # You can pass an array of data in this way: Route::get(\"/home\", function(){ return view('test', [ 'foo' => 'bar', 'one' => 1 ]); }); In your view, you can access these data as variables. The variable names will be same as the array keys: <?= $foo ?>","title":"Intro to the Views"},{"location":"views/intro_to_the_views/#intro-to-the-views","text":"In the route callback function, instead of returning some string, we render a view and then return it. We can do this using the global view() function or return a View object: Route::get(\"/\", function(){ return view('home'); }); Route::get(\"/home\", function(){ return new View('home'); }); Now this view() function or View object checks if the resources/views/ directory contains a view named [given_name].php or [given_name].power.php ; if exists then it returns the whole content of the file as a string. In this case the [given_name] is home . You can specify folders: Route::get(\"/home\", function(){ return new View('test/home'); }); Using . (dot): Route::get(\"/home\", function(){ return new View('test.home'); // same as above }); If the given view doesn't exist then it will throw a `FileNotFoundException`.","title":"Intro to the Views"},{"location":"views/intro_to_the_views/#passing-data-to-the-views","text":"You can pass an array of data in this way: Route::get(\"/home\", function(){ return view('test', [ 'foo' => 'bar', 'one' => 1 ]); }); In your view, you can access these data as variables. The variable names will be same as the array keys: <?= $foo ?>","title":"Passing data to the views"},{"location":"views/layouts/","text":"Layouts # A layout is a special type of view that can be extended by other views. In short, layouts are the blueprints for the views. Using layouts can make our code less. If your website has multiple pages, then there is a great chance of having some common HTML code such as header, footer, navbar, copyright text... etc. And you can keep these common code in a single file, which is generally a layout. Creating a layout is very simple, navigate to resources/views/layouts/ directory and create a new file main.php . Also you can create main.power.php if you want to use PowerParser. Then open the file and add these things if you're not using PowerParser: <html lang=\"en\"> <head> <meta charset=\"UTF-8\"> <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"> <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"> <title>My First App</title> </head> <body> [[ view ]] </body> </html> Alternatively, add these things if you're using PowerParser: <html lang=\"en\"> <head> <meta charset=\"UTF-8\"> <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"> <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"> <title>My First App</title> </head> <body> :yield('content'): </body> </html> Then, you need to extend this layout in other views. Now, in the first case we've used [[ view ]] and this tells your app that replace that token with the incoming view content. The :yield() directive is almost same as [[ view ]] . If you're not using PowerParser, then you need to open the config/app.php file add edit the layout field and add the layout path to the field. In this case, it is layouts/main . Note that the extensions are not allowed here, just pass the base name. Then you can create a new view test.php and then add some code: <h1>Hello world!</h1> <p>Your layout and view(s) are working!</p> And now you can add a test route to the routes/web.php file which simply returns a view (In this case it is test ): Route::get('/testing-a-view', function(){ return view('test'); }); And hopefully in the browser you should see the title My First App which means the layout is working and you should also see other stuff in the view. Now, if you're using PowerParser, then follow these steps: Create a new view test.power.php (Remember, the extension .power.php tells your app that it is a PowerParser file, and .php tells you app that it is a simple PHP file.): :extends('layouts.main'): :section('content'): <h1>Hello world!</h1> <p>Your layout and view(s) are working!</p> :endsection: And then add a new route as done before. Now, hopefully you should see the same result. Both of those views are rendered like this: <html lang=\"en\"> <head> <meta charset=\"UTF-8\"> <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"> <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"> <title>My First App</title> </head> <body> <h1>Hello world!</h1> <p>Your layout and view(s) are working!</p> </body> </html>","title":"Layouts"},{"location":"views/layouts/#layouts","text":"A layout is a special type of view that can be extended by other views. In short, layouts are the blueprints for the views. Using layouts can make our code less. If your website has multiple pages, then there is a great chance of having some common HTML code such as header, footer, navbar, copyright text... etc. And you can keep these common code in a single file, which is generally a layout. Creating a layout is very simple, navigate to resources/views/layouts/ directory and create a new file main.php . Also you can create main.power.php if you want to use PowerParser. Then open the file and add these things if you're not using PowerParser: <html lang=\"en\"> <head> <meta charset=\"UTF-8\"> <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"> <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"> <title>My First App</title> </head> <body> [[ view ]] </body> </html> Alternatively, add these things if you're using PowerParser: <html lang=\"en\"> <head> <meta charset=\"UTF-8\"> <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"> <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"> <title>My First App</title> </head> <body> :yield('content'): </body> </html> Then, you need to extend this layout in other views. Now, in the first case we've used [[ view ]] and this tells your app that replace that token with the incoming view content. The :yield() directive is almost same as [[ view ]] . If you're not using PowerParser, then you need to open the config/app.php file add edit the layout field and add the layout path to the field. In this case, it is layouts/main . Note that the extensions are not allowed here, just pass the base name. Then you can create a new view test.php and then add some code: <h1>Hello world!</h1> <p>Your layout and view(s) are working!</p> And now you can add a test route to the routes/web.php file which simply returns a view (In this case it is test ): Route::get('/testing-a-view', function(){ return view('test'); }); And hopefully in the browser you should see the title My First App which means the layout is working and you should also see other stuff in the view. Now, if you're using PowerParser, then follow these steps: Create a new view test.power.php (Remember, the extension .power.php tells your app that it is a PowerParser file, and .php tells you app that it is a simple PHP file.): :extends('layouts.main'): :section('content'): <h1>Hello world!</h1> <p>Your layout and view(s) are working!</p> :endsection: And then add a new route as done before. Now, hopefully you should see the same result. Both of those views are rendered like this: <html lang=\"en\"> <head> <meta charset=\"UTF-8\"> <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"> <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"> <title>My First App</title> </head> <body> <h1>Hello world!</h1> <p>Your layout and view(s) are working!</p> </body> </html>","title":"Layouts"},{"location":"views/meet_powerparser/","text":"Meet PowerParser # PowerParser is a strong, regex-based and excellent templating engine which will make your work and code less. PowerParser is included with Invention Framework, so you don't need to worry about that. PowerParser supports a bunch of directives that can make your code elegant and less. If you're familier with Laravel Framework , then you should probably know about Laravel's Blade Directives , and PowerParser supports almost every directive of Blade! For example, an if statement in Blade: @if(condition) <!--HTML--> @endif But in PowerParser, you need to write the same statement in this way: :if(condition): <!--HTML--> :endif: Outputting something: {{ \"text\" }} {{ $variable }} {{ func() }} PowerParser will call htmlspecialchars() and filter strings every time when you output something in this way. Also you might need a single line PHP code which should not be outputted, for that use this: !{{ \"Text\" }}! <!--Nothing is outputted--> !{{ $variable++ }}! <!--Increments $variable by 1--> !{{ $var = func() }}! <!--Calls func() and assigns the return value to $var--->","title":"Meet PowerParser"},{"location":"views/meet_powerparser/#meet-powerparser","text":"PowerParser is a strong, regex-based and excellent templating engine which will make your work and code less. PowerParser is included with Invention Framework, so you don't need to worry about that. PowerParser supports a bunch of directives that can make your code elegant and less. If you're familier with Laravel Framework , then you should probably know about Laravel's Blade Directives , and PowerParser supports almost every directive of Blade! For example, an if statement in Blade: @if(condition) <!--HTML--> @endif But in PowerParser, you need to write the same statement in this way: :if(condition): <!--HTML--> :endif: Outputting something: {{ \"text\" }} {{ $variable }} {{ func() }} PowerParser will call htmlspecialchars() and filter strings every time when you output something in this way. Also you might need a single line PHP code which should not be outputted, for that use this: !{{ \"Text\" }}! <!--Nothing is outputted--> !{{ $variable++ }}! <!--Increments $variable by 1--> !{{ $var = func() }}! <!--Calls func() and assigns the return value to $var--->","title":"Meet PowerParser"},{"location":"views/powerparser_directive_args/","text":"PowerParser Directive: :args(): # This directive finds an argument with the given index and outputs it. This directive is only available in components ; Syntax # :args(argument_index): Example # View :component('some-component', 'Arg1', 'Arg2', 'Last Arg'): Component: <p>:args(0):</p> <p>:args(1):</p> <p>:args(2):</p> Output: <p>Arg1</p> <p>Arg2</p> <p>Last Arg</p>","title":"PowerParser Directive: :args():"},{"location":"views/powerparser_directive_args/#powerparser-directive-args","text":"This directive finds an argument with the given index and outputs it. This directive is only available in components ;","title":"PowerParser Directive: :args():"},{"location":"views/powerparser_directive_args/#syntax","text":":args(argument_index):","title":"Syntax"},{"location":"views/powerparser_directive_args/#example","text":"View :component('some-component', 'Arg1', 'Arg2', 'Last Arg'): Component: <p>:args(0):</p> <p>:args(1):</p> <p>:args(2):</p> Output: <p>Arg1</p> <p>Arg2</p> <p>Last Arg</p>","title":"Example"},{"location":"views/powerparser_directive_component/","text":"PowerParser Directive: :component(): # This directive parses and outputs a view component. You can read more about view components here . Syntax # :component(name, [args...]): Example # Component component/button.power.php <button class=\"btn btn-primary:args(0):\" type=\":args(1):\">:args(2):</button> View: <html lang=\"en\"> <head> <meta charset=\"UTF-8\"> <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"> <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"> <title>My First App</title> </head> <body> <h1>Components</h1> <form action=\"\"> <input type=\"text\"> :component('button', ' me-2', 'submit', 'Submit'): :component('button', ' me-2', 'button', 'Normal Button'): :component('button', '', 'reset', 'Reset'): </form> </body> </html> This will output: <html lang=\"en\"> <head> <meta charset=\"UTF-8\"> <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"> <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"> <title>My First App</title> </head> <body> <h1>Components</h1> <form action=\"\"> <input type=\"text\"> <button class=\"btn btn-primary me-2\" type=\"submit\">Submit</button> <button class=\"btn btn-primary me-2\" type=\"button\">Normal Button</button> <button class=\"btn btn-primary\" type=\"reset\">Reset</button> </form> </body> </html>","title":"PowerParser Directive: :component():"},{"location":"views/powerparser_directive_component/#powerparser-directive-component","text":"This directive parses and outputs a view component. You can read more about view components here .","title":"PowerParser Directive: :component():"},{"location":"views/powerparser_directive_component/#syntax","text":":component(name, [args...]):","title":"Syntax"},{"location":"views/powerparser_directive_component/#example","text":"Component component/button.power.php <button class=\"btn btn-primary:args(0):\" type=\":args(1):\">:args(2):</button> View: <html lang=\"en\"> <head> <meta charset=\"UTF-8\"> <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"> <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"> <title>My First App</title> </head> <body> <h1>Components</h1> <form action=\"\"> <input type=\"text\"> :component('button', ' me-2', 'submit', 'Submit'): :component('button', ' me-2', 'button', 'Normal Button'): :component('button', '', 'reset', 'Reset'): </form> </body> </html> This will output: <html lang=\"en\"> <head> <meta charset=\"UTF-8\"> <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"> <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"> <title>My First App</title> </head> <body> <h1>Components</h1> <form action=\"\"> <input type=\"text\"> <button class=\"btn btn-primary me-2\" type=\"submit\">Submit</button> <button class=\"btn btn-primary me-2\" type=\"button\">Normal Button</button> <button class=\"btn btn-primary\" type=\"reset\">Reset</button> </form> </body> </html>","title":"Example"},{"location":"views/powerparser_directive_csrf/","text":"PowerParser Directive: :csrf: # You can use this directive to attach a hidden input element with a random Cross-Site Request Forgery (CSRF) Token. It has the name of __csrf_token and this authorizes the form to be submitted and the data goes to the controller. If any POST, PUT, PATCH or DELETE request doesn't specify the __csrf_token or the __csrf_token is invalid, then the request will be rejected with a status of 419 Page Expired . This behaviour is controlled by the VerfyCSRF middleware which is included with your project. Syntax # :csrf: Example # View <form action=\"/users\" method=\"post\"> :csrf: <input type=\"text\" name=\"username\"> <button type=\"submit\" class=\"btn btn-custom\">Submit</button> </form> Output: <form action=\"/users\" method=\"post\"> <input type=\"hidden\" name=\"__csrf_token\" value=\"f7ff9e8b7bb2e09b70935a5d785e0cc5d9d0abf0\"> <input type=\"text\" name=\"username\"> <button type=\"submit\" class=\"btn btn-custom\">Submit</button> </form>","title":"PowerParser Directive: :csrf:"},{"location":"views/powerparser_directive_csrf/#powerparser-directive-csrf","text":"You can use this directive to attach a hidden input element with a random Cross-Site Request Forgery (CSRF) Token. It has the name of __csrf_token and this authorizes the form to be submitted and the data goes to the controller. If any POST, PUT, PATCH or DELETE request doesn't specify the __csrf_token or the __csrf_token is invalid, then the request will be rejected with a status of 419 Page Expired . This behaviour is controlled by the VerfyCSRF middleware which is included with your project.","title":"PowerParser Directive: :csrf:"},{"location":"views/powerparser_directive_csrf/#syntax","text":":csrf:","title":"Syntax"},{"location":"views/powerparser_directive_csrf/#example","text":"View <form action=\"/users\" method=\"post\"> :csrf: <input type=\"text\" name=\"username\"> <button type=\"submit\" class=\"btn btn-custom\">Submit</button> </form> Output: <form action=\"/users\" method=\"post\"> <input type=\"hidden\" name=\"__csrf_token\" value=\"f7ff9e8b7bb2e09b70935a5d785e0cc5d9d0abf0\"> <input type=\"text\" name=\"username\"> <button type=\"submit\" class=\"btn btn-custom\">Submit</button> </form>","title":"Example"},{"location":"views/powerparser_directive_dowhile/","text":"PowerParser Directive: :dowhile: # This is equivalent to PHP do-while loops. Syntax # :dowhile: <!--HTML or Other PowerParser Directive--> :enddowhile(condition): Example # <ul> !{{ $i = 1 }}! :dowhile: <li>Page {{ $i }}</li> !{{ $i++ }}! :enddowhile($i <= 0): </ul> This will output: Page 1","title":"PowerParser Directive: :dowhile():"},{"location":"views/powerparser_directive_dowhile/#powerparser-directive-dowhile","text":"This is equivalent to PHP do-while loops.","title":"PowerParser Directive: :dowhile:"},{"location":"views/powerparser_directive_dowhile/#syntax","text":":dowhile: <!--HTML or Other PowerParser Directive--> :enddowhile(condition):","title":"Syntax"},{"location":"views/powerparser_directive_dowhile/#example","text":"<ul> !{{ $i = 1 }}! :dowhile: <li>Page {{ $i }}</li> !{{ $i++ }}! :enddowhile($i <= 0): </ul> This will output: Page 1","title":"Example"},{"location":"views/powerparser_directive_extends/","text":"PowerParser Directive: :extends(): # This directive finds a view or layout with the given name/path and includes it to the current view . Syntax # :extends(view_file): Example # View :extends('layouts.base'): :title('Users Page'): :section('main'): <h1>Users</h1> <ul> <li>User 1</li> <li>User 2</li> <li>User 3</li> </ul> :endsection: Layout: <!DOCTYPE html> <html lang=\"en\"> <head> <meta charset=\"UTF-8\"> <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"> <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"> <title>{{ $_title }}</title> </head> <body> :yield('main'): </body> </html> Output: <!DOCTYPE html> <html lang=\"en\"> <head> <meta charset=\"UTF-8\"> <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"> <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"> <title>Users Page</title> </head> <body> <h1>Users</h1> <ul> <li>User 1</li> <li>User 2</li> <li>User 3</li> </ul> </body> </html>","title":"PowerParser Directive: :extends():"},{"location":"views/powerparser_directive_extends/#powerparser-directive-extends","text":"This directive finds a view or layout with the given name/path and includes it to the current view .","title":"PowerParser Directive: :extends():"},{"location":"views/powerparser_directive_extends/#syntax","text":":extends(view_file):","title":"Syntax"},{"location":"views/powerparser_directive_extends/#example","text":"View :extends('layouts.base'): :title('Users Page'): :section('main'): <h1>Users</h1> <ul> <li>User 1</li> <li>User 2</li> <li>User 3</li> </ul> :endsection: Layout: <!DOCTYPE html> <html lang=\"en\"> <head> <meta charset=\"UTF-8\"> <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"> <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"> <title>{{ $_title }}</title> </head> <body> :yield('main'): </body> </html> Output: <!DOCTYPE html> <html lang=\"en\"> <head> <meta charset=\"UTF-8\"> <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"> <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"> <title>Users Page</title> </head> <body> <h1>Users</h1> <ul> <li>User 1</li> <li>User 2</li> <li>User 3</li> </ul> </body> </html>","title":"Example"},{"location":"views/powerparser_directive_for/","text":"PowerParser Directive: :for(): # This is equivalent to PHP for loops. Syntax # :for(initialization; condition; expression): <!--HTML or Other PowerParser Directive--> :endfor: Example # <ul> :for($i = 1; $i <= 5; $i++): <li>Page {{ $i }}</li> :endfor: </ul> This will output: Page 1 Page 2 Page 3 Page 4 Page 5","title":"PowerParser Directive: :for():"},{"location":"views/powerparser_directive_for/#powerparser-directive-for","text":"This is equivalent to PHP for loops.","title":"PowerParser Directive: :for():"},{"location":"views/powerparser_directive_for/#syntax","text":":for(initialization; condition; expression): <!--HTML or Other PowerParser Directive--> :endfor:","title":"Syntax"},{"location":"views/powerparser_directive_for/#example","text":"<ul> :for($i = 1; $i <= 5; $i++): <li>Page {{ $i }}</li> :endfor: </ul> This will output: Page 1 Page 2 Page 3 Page 4 Page 5","title":"Example"},{"location":"views/powerparser_directive_foreach/","text":"PowerParser Directive: :foreach(): # This is equivalent to PHP foreach loops. Syntax # :foreach($array_or_object as $value): <!--HTML or Other PowerParser Directive--> :endforeach: or, :foreach($array_or_object as $key => $value): <!--HTML or Other PowerParser Directive--> :endforeach: Example # <ul> :foreach($_SERVER as $key => $value): <li>{{ $key }} => {{ $value }}</li> :endforeach: </ul> This will print out all $_SERVER key-value pairs.","title":"PowerParser Directive: :foreach():"},{"location":"views/powerparser_directive_foreach/#powerparser-directive-foreach","text":"This is equivalent to PHP foreach loops.","title":"PowerParser Directive: :foreach():"},{"location":"views/powerparser_directive_foreach/#syntax","text":":foreach($array_or_object as $value): <!--HTML or Other PowerParser Directive--> :endforeach: or, :foreach($array_or_object as $key => $value): <!--HTML or Other PowerParser Directive--> :endforeach:","title":"Syntax"},{"location":"views/powerparser_directive_foreach/#example","text":"<ul> :foreach($_SERVER as $key => $value): <li>{{ $key }} => {{ $value }}</li> :endforeach: </ul> This will print out all $_SERVER key-value pairs.","title":"Example"},{"location":"views/powerparser_directive_if/","text":"PowerParser Directive: :if(): # This is equivalent to PHP if statements. Simple If Conditions # :if(condition): <!--HTML or Other PowerParser Directive--> :endif: If-else Conditions # :if(condition): <!--HTML or Other PowerParser Directive--> :else: <!--HTML or Other PowerParser Directive--> :endif: If-elseif-else Conditions # :if(condition): <!--HTML or Other PowerParser Directive--> :elseif(condition): <!--HTML or Other PowerParser Directive--> :elseif(condition): <!--HTML or Other PowerParser Directive--> :else: <!--HTML or Other PowerParser Directive--> :endif: Examples # <div> !{{ $i = 1 }}! :if($i === 1): <p>{{ $i }} is equal to 1</p> :endif: :if($i === 2): <p>{{ $i }} is equal to 2</p> :endif: </div> This will output: <div> <p>1 is equal to 1</p> </div> <div> !{{ $i = 2 }}! :if($i === 1): <p>{{ $i }} is equal to 1</p> :else: <p>{{ $i }} is not equal to 1</p> :endif: </div> This will output: <div> <p>2 is not equal to 1</p> </div> <div> !{{ $i = 2 }}! :if($i === 1): <p>{{ $i }} is equal to 1</p> :elseif($i === 2): <p>{{ $i }} is equal to 2</p> :else: <p>{{ $i }} is not equal to 1 or 2</p> :endif: </div> This will output: <div> <p>2 is equal to 2</p> </div>","title":"PowerParser Directive: :if():"},{"location":"views/powerparser_directive_if/#powerparser-directive-if","text":"This is equivalent to PHP if statements.","title":"PowerParser Directive: :if():"},{"location":"views/powerparser_directive_if/#simple-if-conditions","text":":if(condition): <!--HTML or Other PowerParser Directive--> :endif:","title":"Simple If Conditions"},{"location":"views/powerparser_directive_if/#if-else-conditions","text":":if(condition): <!--HTML or Other PowerParser Directive--> :else: <!--HTML or Other PowerParser Directive--> :endif:","title":"If-else Conditions"},{"location":"views/powerparser_directive_if/#if-elseif-else-conditions","text":":if(condition): <!--HTML or Other PowerParser Directive--> :elseif(condition): <!--HTML or Other PowerParser Directive--> :elseif(condition): <!--HTML or Other PowerParser Directive--> :else: <!--HTML or Other PowerParser Directive--> :endif:","title":"If-elseif-else Conditions"},{"location":"views/powerparser_directive_if/#examples","text":"<div> !{{ $i = 1 }}! :if($i === 1): <p>{{ $i }} is equal to 1</p> :endif: :if($i === 2): <p>{{ $i }} is equal to 2</p> :endif: </div> This will output: <div> <p>1 is equal to 1</p> </div> <div> !{{ $i = 2 }}! :if($i === 1): <p>{{ $i }} is equal to 1</p> :else: <p>{{ $i }} is not equal to 1</p> :endif: </div> This will output: <div> <p>2 is not equal to 1</p> </div> <div> !{{ $i = 2 }}! :if($i === 1): <p>{{ $i }} is equal to 1</p> :elseif($i === 2): <p>{{ $i }} is equal to 2</p> :else: <p>{{ $i }} is not equal to 1 or 2</p> :endif: </div> This will output: <div> <p>2 is equal to 2</p> </div>","title":"Examples"},{"location":"views/powerparser_directive_method/","text":"PowerParser Directive: :method(): # You can use this directive to attach a hidden input element with the given HTTP method, and a name of __method . This emulates the HTTP method action calling procedure. The browsers can only send GET and POST requests, and if you want to use other method rather than POST , this directive can be quite handy. Note that the actual method of the request is always `POST` or `GET`, but the application can understand which method should be triggered from the `__method` field of the request. Syntax # :method(method): Example # View <form action=\"/users\" method=\"post\"> :method(\"PATCH\"): :csrf: <input type=\"text\" name=\"username\"> <button type=\"submit\" class=\"btn btn-custom\">Submit</button> </form> Output: <form action=\"/users\" method=\"post\"> <input type=\"hidden\" name=\"__method\" value=\"PATCH\"> <input type=\"hidden\" name=\"__csrf_token\" value=\"f7ff9e8b7bb2e09b70935a5d785e0cc5d9d0abf0\"> <input type=\"text\" name=\"username\"> <button type=\"submit\" class=\"btn btn-custom\">Submit</button> </form> If we a a route file like this: Route::get(\"/users\", function(){ return new View('form'); }); Route::post(\"/users\", function(){ return 'Handling given data from POST.'; }); Route::patch(\"/users\", function(){ return 'Handling given data from PATCH.'; }); Then after clicking the submit button we should see Handling given data from PATCH. in the browser.","title":"PowerParser Directive: :method():"},{"location":"views/powerparser_directive_method/#powerparser-directive-method","text":"You can use this directive to attach a hidden input element with the given HTTP method, and a name of __method . This emulates the HTTP method action calling procedure. The browsers can only send GET and POST requests, and if you want to use other method rather than POST , this directive can be quite handy. Note that the actual method of the request is always `POST` or `GET`, but the application can understand which method should be triggered from the `__method` field of the request.","title":"PowerParser Directive: :method():"},{"location":"views/powerparser_directive_method/#syntax","text":":method(method):","title":"Syntax"},{"location":"views/powerparser_directive_method/#example","text":"View <form action=\"/users\" method=\"post\"> :method(\"PATCH\"): :csrf: <input type=\"text\" name=\"username\"> <button type=\"submit\" class=\"btn btn-custom\">Submit</button> </form> Output: <form action=\"/users\" method=\"post\"> <input type=\"hidden\" name=\"__method\" value=\"PATCH\"> <input type=\"hidden\" name=\"__csrf_token\" value=\"f7ff9e8b7bb2e09b70935a5d785e0cc5d9d0abf0\"> <input type=\"text\" name=\"username\"> <button type=\"submit\" class=\"btn btn-custom\">Submit</button> </form> If we a a route file like this: Route::get(\"/users\", function(){ return new View('form'); }); Route::post(\"/users\", function(){ return 'Handling given data from POST.'; }); Route::patch(\"/users\", function(){ return 'Handling given data from PATCH.'; }); Then after clicking the submit button we should see Handling given data from PATCH. in the browser.","title":"Example"},{"location":"views/powerparser_directive_php/","text":"PowerParser Directive: :php: # You can write plain PHP code inside this directive. Syntax # :php: // php code :endphp: Example # <ul> :php: for($i = 0; $i < 5; $i++) { echo \"<li>{$i}</li>\"; } :endphp: </ul> This will output: <ul> <li>1</li> <li>2</li> <li>3</li> <li>4</li> <li>5</li> </ul>","title":"PowerParser Directive: :php:"},{"location":"views/powerparser_directive_php/#powerparser-directive-php","text":"You can write plain PHP code inside this directive.","title":"PowerParser Directive: :php:"},{"location":"views/powerparser_directive_php/#syntax","text":":php: // php code :endphp:","title":"Syntax"},{"location":"views/powerparser_directive_php/#example","text":"<ul> :php: for($i = 0; $i < 5; $i++) { echo \"<li>{$i}</li>\"; } :endphp: </ul> This will output: <ul> <li>1</li> <li>2</li> <li>3</li> <li>4</li> <li>5</li> </ul>","title":"Example"},{"location":"views/powerparser_directive_section/","text":"PowerParser Directive: :section():: # Starts an output buffer and saves it, which can be retrived back with an Yield directive. If multiple sections have the same name, then the last section's output buffer will be returned; because it overwrites the data. Syntax # :section(name): <!--HTML or Other PowerParser Directive--> :endsection: Example # View: :extends('layouts.app'): :section('header'): <h1>Header</h1> :endsection: :section('footer'): <small>Footer</small> :endsection: :section('body'): <p>Body</p> :endsection: Layout layouts/app.power.php <html lang=\"en\"> <head> <meta charset=\"UTF-8\"> <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"> <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"> <title>My First App</title> </head> <body> <header> :yield('header'): </header> <main> :yield('body'): </main> <footer> :yield('footer'): </footer> </body> </html> This will output: <html lang=\"en\"> <head> <meta charset=\"UTF-8\"> <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"> <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"> <title>My First App</title> </head> <body> <header> <h1>Header</h1> </header> <main> <p>Body</p> </main> <footer> <small>Footer</small> </footer> </body> </html>","title":"PowerParser Directive: :section():"},{"location":"views/powerparser_directive_section/#powerparser-directive-section","text":"Starts an output buffer and saves it, which can be retrived back with an Yield directive. If multiple sections have the same name, then the last section's output buffer will be returned; because it overwrites the data.","title":"PowerParser Directive: :section()::"},{"location":"views/powerparser_directive_section/#syntax","text":":section(name): <!--HTML or Other PowerParser Directive--> :endsection:","title":"Syntax"},{"location":"views/powerparser_directive_section/#example","text":"View: :extends('layouts.app'): :section('header'): <h1>Header</h1> :endsection: :section('footer'): <small>Footer</small> :endsection: :section('body'): <p>Body</p> :endsection: Layout layouts/app.power.php <html lang=\"en\"> <head> <meta charset=\"UTF-8\"> <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"> <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"> <title>My First App</title> </head> <body> <header> :yield('header'): </header> <main> :yield('body'): </main> <footer> :yield('footer'): </footer> </body> </html> This will output: <html lang=\"en\"> <head> <meta charset=\"UTF-8\"> <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"> <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"> <title>My First App</title> </head> <body> <header> <h1>Header</h1> </header> <main> <p>Body</p> </main> <footer> <small>Footer</small> </footer> </body> </html>","title":"Example"},{"location":"views/powerparser_directive_title/","text":"PowerParser Directive: :title(): # This directive is generally used in Layouts . This directive tells PowerParser that get the title specified in the views, and create a variable $_title with that value. Then it can be used in the layout to set the page title. Using multiple `:title():` statements will overwrite the variable `$_title`. Syntax # :title(page_title): Example # Layout layouts/app.power.php <html lang=\"en\"> <head> <meta charset=\"UTF-8\"> <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"> <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"> <title>{{ $_title }}</title> </head> <body> <div class=\"container\"> :yield('body'): </div> </body> </html> View: :extends('layouts.app'): :title(\"Login - MyApp\"): :section('body'): <p>Body</p> :endsection: This will output: <html lang=\"en\"> <head> <meta charset=\"UTF-8\"> <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"> <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"> <title>Login - MyApp</title> </head> <body> <div class=\"container\"> <p>Body</p> </div> </body> </html>","title":"PowerParser Directive: :title():"},{"location":"views/powerparser_directive_title/#powerparser-directive-title","text":"This directive is generally used in Layouts . This directive tells PowerParser that get the title specified in the views, and create a variable $_title with that value. Then it can be used in the layout to set the page title. Using multiple `:title():` statements will overwrite the variable `$_title`.","title":"PowerParser Directive: :title():"},{"location":"views/powerparser_directive_title/#syntax","text":":title(page_title):","title":"Syntax"},{"location":"views/powerparser_directive_title/#example","text":"Layout layouts/app.power.php <html lang=\"en\"> <head> <meta charset=\"UTF-8\"> <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"> <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"> <title>{{ $_title }}</title> </head> <body> <div class=\"container\"> :yield('body'): </div> </body> </html> View: :extends('layouts.app'): :title(\"Login - MyApp\"): :section('body'): <p>Body</p> :endsection: This will output: <html lang=\"en\"> <head> <meta charset=\"UTF-8\"> <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"> <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"> <title>Login - MyApp</title> </head> <body> <div class=\"container\"> <p>Body</p> </div> </body> </html>","title":"Example"},{"location":"views/powerparser_directive_while/","text":"PowerParser Directive: :while(): # This is equivalent to PHP while loops. Syntax # :while(condition): <!--HTML or Other PowerParser Directive--> :endwhile: Example # <ul> !{{ $i = 1 }}! :while($i <= 5): <li>Page {{ $i }}</li> !{{ $i++ }}! :endwhile: </ul> This will output: <ul> <li>Page 1</li> <li>Page 2</li> <li>Page 3</li> <li>Page 4</li> <li>Page 5</li> </ul>","title":"PowerParser Directive: :while():"},{"location":"views/powerparser_directive_while/#powerparser-directive-while","text":"This is equivalent to PHP while loops.","title":"PowerParser Directive: :while():"},{"location":"views/powerparser_directive_while/#syntax","text":":while(condition): <!--HTML or Other PowerParser Directive--> :endwhile:","title":"Syntax"},{"location":"views/powerparser_directive_while/#example","text":"<ul> !{{ $i = 1 }}! :while($i <= 5): <li>Page {{ $i }}</li> !{{ $i++ }}! :endwhile: </ul> This will output: <ul> <li>Page 1</li> <li>Page 2</li> <li>Page 3</li> <li>Page 4</li> <li>Page 5</li> </ul>","title":"Example"},{"location":"views/powerparser_directive_yield/","text":"PowerParser Directive: :yield(): # This directive is generally used in Layouts . This directive tells PowerParser that find a Section which has the same name as given and then output it where the :yield: directive is used. You can use multiple :yield: directives. If a section with the given name doesn't exist then nothing will be outputted. Syntax # :yield(section_name): Example # Layout layouts/app.power.php <html lang=\"en\"> <head> <meta charset=\"UTF-8\"> <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"> <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"> <title>My First App</title> </head> <body> <header> :yield('header'): </header> <main> :yield('body'): </main> <footer> :yield('footer'): </footer> </body> </html> View: :extends('layouts.app'): :section('header'): <h1>Header</h1> :endsection: :section('footer'): <small>Footer</small> :endsection: :section('body'): <p>Body</p> :endsection: This will output: <html lang=\"en\"> <head> <meta charset=\"UTF-8\"> <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"> <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"> <title>My First App</title> </head> <body> <header> <h1>Header</h1> </header> <main> <p>Body</p> </main> <footer> <small>Footer</small> </footer> </body> </html>","title":"PowerParser Directive: :yield():"},{"location":"views/powerparser_directive_yield/#powerparser-directive-yield","text":"This directive is generally used in Layouts . This directive tells PowerParser that find a Section which has the same name as given and then output it where the :yield: directive is used. You can use multiple :yield: directives. If a section with the given name doesn't exist then nothing will be outputted.","title":"PowerParser Directive: :yield():"},{"location":"views/powerparser_directive_yield/#syntax","text":":yield(section_name):","title":"Syntax"},{"location":"views/powerparser_directive_yield/#example","text":"Layout layouts/app.power.php <html lang=\"en\"> <head> <meta charset=\"UTF-8\"> <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"> <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"> <title>My First App</title> </head> <body> <header> :yield('header'): </header> <main> :yield('body'): </main> <footer> :yield('footer'): </footer> </body> </html> View: :extends('layouts.app'): :section('header'): <h1>Header</h1> :endsection: :section('footer'): <small>Footer</small> :endsection: :section('body'): <p>Body</p> :endsection: This will output: <html lang=\"en\"> <head> <meta charset=\"UTF-8\"> <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"> <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"> <title>My First App</title> </head> <body> <header> <h1>Header</h1> </header> <main> <p>Body</p> </main> <footer> <small>Footer</small> </footer> </body> </html>","title":"Example"},{"location":"views/powerparser_directives/","text":"PowerParser Directives # All PowerParser directives are listed here: :args(): :component(): :csrf: :dowhile(): :extends(): :for(): :foreach(): :if(): :method(): :php: :section(): :title(): :while(): :yield():","title":"PowerParser Directives"},{"location":"views/powerparser_directives/#powerparser-directives","text":"All PowerParser directives are listed here: :args(): :component(): :csrf: :dowhile(): :extends(): :for(): :foreach(): :if(): :method(): :php: :section(): :title(): :while(): :yield():","title":"PowerParser Directives"},{"location":"views/view_components/","text":"View Components # View components are a special type of views. They can contain some or a lot of HTML widgets such as navbars, lists, buttons..., but the standard is to keep a single widget in a component. View components are quite handy when you want to use same HTML code in some of your views. View components are placed at resources/views/components/ directory. Component files must have the extension .power.php . Let's see a quick example with a simple bootstrap submit button: Component components/button.power.php <button class=\"btn btn-primary\" type=\"submit\">Submit</button> Now this component can be used in views or layouts; in the following way: :component(\"button\"): Which means you need to use the :component: directive and inside it, you need to pass the base name of the component. The above code will return the whole content of the component button.power.php . Components can also have argument parameters. You can use arguments in your components in this way: :args([argument index...]): For example: Component components/button.power.php <button class=\"btn btn-primary\" type=\"submit\">:args(0):</button> And now you need to use this component with a parameter: :component(\"button\", \"Submit\"): Output: <button class=\"btn btn-primary\" type=\"submit\">Submit</button>","title":"View Components"},{"location":"views/view_components/#view-components","text":"View components are a special type of views. They can contain some or a lot of HTML widgets such as navbars, lists, buttons..., but the standard is to keep a single widget in a component. View components are quite handy when you want to use same HTML code in some of your views. View components are placed at resources/views/components/ directory. Component files must have the extension .power.php . Let's see a quick example with a simple bootstrap submit button: Component components/button.power.php <button class=\"btn btn-primary\" type=\"submit\">Submit</button> Now this component can be used in views or layouts; in the following way: :component(\"button\"): Which means you need to use the :component: directive and inside it, you need to pass the base name of the component. The above code will return the whole content of the component button.power.php . Components can also have argument parameters. You can use arguments in your components in this way: :args([argument index...]): For example: Component components/button.power.php <button class=\"btn btn-primary\" type=\"submit\">:args(0):</button> And now you need to use this component with a parameter: :component(\"button\", \"Submit\"): Output: <button class=\"btn btn-primary\" type=\"submit\">Submit</button>","title":"View Components"}]}